!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).axel_sdk={})}(this,(function(e){"use strict";function t(e,t,n,o){if("a"===n&&!o)throw new TypeError("Private accessor was defined without a getter");if("function"==typeof t?e!==t||!o:!t.has(e))throw new TypeError("Cannot read private member from an object whose class did not declare it");return"m"===n?o:"a"===n?o.call(e):o?o.value:t.get(e)}var n;class o extends Error{constructor(e){const s=[""];for(const r of e)if(r instanceof o)for(const e of t(r,n,"f"))s.push(`> > ${e}`);else s.push(`> ${r}`);super(s.join("\n")),n.set(this,void 0),function(e,t,n,o,s){if("m"===o)throw new TypeError("Private method is not writable");if("a"===o&&!s)throw new TypeError("Private accessor was defined without a setter");if("function"==typeof t?e!==t||!s:!t.has(e))throw new TypeError("Cannot write private member to an object whose class did not declare it");"a"===o?s.call(e,n):s?s.value=n:t.set(e,n)}(this,n,s,"f")}}n=new WeakMap;class s extends o{constructor(e){super(e)}}const r=e=>e;function a(e){return"string"==typeof e?`"${e}"`:""+e}const i=r,c=i,u=r,h=r;function l(e,t){return u(e.includes(t))}function p(e,t,n){if(!e.includes(n))throw new s([`Could not assert that input is a ${t}!`,`elem was ${a(n)} but should have been one of the following:`,...e.map((e=>`- ${a(e)}`))])}function d(e,t){return{assert(n){p(e,t,n)},typename:t}}function f(e){const t=Object.keys(e);return g(t),u(t)}const y={assert(e){if("object"!=typeof e)throw new s(["Could not assert that value is non-null object because of runtime type mismatch!",`typeof value was ${a(typeof e)} instead of "object".`]);if(null===e)throw new s(["Could not assert that value is non-null object because value was null!"])},typename:"non-null object"},w=(e,t)=>Object.hasOwnProperty.call(t,e);function _(e,t){if(!w(e,t))throw new s([`Object did not have key ${a(e)}!`])}function m(e,t,n){_(e,n);try{t.assert(n[e])}catch(n){throw n instanceof s?new s([`While asserting that object[${a(e)}] is of type ${t.typename}`,"an error was thrown:",n]):n}}function b(e,t,n){if(w(e,n))try{t.assert(n[e])}catch(n){if(n instanceof s)throw new s([`While asserting that object[${a(e)}] has optional value of type ${t.typename}`,"an error was thrown:",n])}}function v(e,t,n){!function(e,t){if(!(e in t))throw new s([`${a(e)} was not in Object!`])}(e,n);try{t.assert(n[e])}catch(n){throw n instanceof s?new s([`While asserting that object[${a(e)}] is of type ${t.typename}`,"an error was thrown:",n]):n}}function g(e){Object.freeze(e)}function x(e,t,n){return u(f(e).filter((o=>e[o][t]===u(n))))}const k={assert(e){if("function"!=typeof e)throw new s(["Could not assert that value is function because",`typeof value was ${a(typeof e)} instead of "function"!`])},typename:"any_fn"},T={assert(e){if("boolean"!=typeof e)throw new s(["Could not assert that value is boolean because",`typeof value was ${a(typeof e)} instead of "boolean"!`])},typename:"boolean"},$={assert(e){if("string"!=typeof e)throw new s(["Could not assert that value is string because",`typeof value was ${a(typeof e)} instead of "string"!`])},typename:"string"},E={assert(e){if("number"!=typeof e)throw new s(["Could not assert that value is number because",`typeof value was ${a(typeof e)} instead of "number"!`]);if(Number.isNaN(e))throw new s(["Could not assert that value is number because value was NaN!"])},typename:"number"},A={assert(e){if(!Number.isInteger(e))throw new s(["Could not assert that value is uint because value was not an integer!",`Value was ${e}.`]);if(e<0)throw new s(["Could not assert that value is uint because value was negative!",`Value was ${e}.`])},typename:"uint"};function j(e){return A.assert(e),e}const P={assert(e){if("number"!=typeof e)throw new s(["Could not assert that value is ufloat because",`typeof value was ${a(typeof e)} instead of "number"!`]);if(Number.isNaN(e))throw new s(["Could not assert that value is ufloat because value is NaN!"]);if(!Number.isFinite(e))throw new s([`Could not assert that value is ufloat because value is ${e}`]);if(e<0)throw new s(["Could not assert that value is ufloat because value is negative!",`Value was ${e}`])},typename:"ufloat"},O={assert(e){if(!Array.isArray(e))throw new s(["Could not assert that value is an array!"])},typename:"array"};const I=["lending","staking","yielding","exchanging"];g(I);const C=d(I,"action_class"),q={lend:{reverse:"unlend",action_class:"lending"},supply:{reverse:"unsupply",action_class:"lending"},borrow:{reverse:"unborrow",action_class:"lending"},stake:{reverse:"unstake",action_class:"staking"},deposit:{reverse:"undeposit",action_class:"yielding"},exchange:{reverse:"exchange",action_class:"exchanging"},unlend:{reverse:"lend",action_class:"lending"},unsupply:{reverse:"supply",action_class:"lending"},unborrow:{reverse:"borrow",action_class:"lending"},unstake:{reverse:"stake",action_class:"staking"},undeposit:{reverse:"deposit",action_class:"yielding"}};g(q);const U=f(q);var D=Object.freeze({__proto__:null,actions:U,info:q,classes:I}),B=Object.freeze({__proto__:null}),R=Object.freeze({__proto__:null});const S={lend:"lending",borrow:"lending",stake:"staking",yield:"yielding"};g(S),f(S);var H=Object.freeze({__proto__:null,info:S});const N=/^[0-9a-f]$/i,z=/^0x[0-9a-f]*$/i;const M={assert(e){if("string"!=typeof e)throw new s([`Input of type ${a(e)} is not of type "string" and therefore`,"cannot be a hex_string."]);if(!e.startsWith("0x"))throw new s(['String does not start with "0x".',`Instead started with "${e.slice(0,2)}".`,"Therefore it is not a hex_string."]);if(t=e,!z.test(t)){const t=[...e.slice(2)].map((e=>N.test(e)?" ":"?")).join("");throw new s(['String starts with "0x" which would indicate a hexadecimal string',"but the value specified is not in base 16",`input = "${e}"`,`           ${t}`])}var t},typename:"hex_string"};function F(e,t){return function(e,t){return u(e/10**t)}(function(e){const t=parseInt(e,16);return A.assert(t),t}(e),t)}const L=["ethereum"];g(L);const Y=["kovan","rinkeby","ropsten","goerli"];g(Y);const W=[...L,...Y];g(W);const K=d(W,"internet"),G=[];function V(e){return l(G,e)}const X={assert(e){p([...L,...Y,...G],"chain",e)},typename:"chain"};const J={assert(e){p(f(Z).map((e=>Z[e].chain_id)),"chain_id",e)},typename:"chain_id"};function Q(e){for(const t of f(Z)){if(Z[t].chain_id===e)return t}throw new o(["src/core/chains.ts::chain_id::to_chain","","If you have seen this, something has gone very, very wrong!","I am pretty sure this can never, ever happen but my assumptions have","been proven wrong before.","This is, *probably* not your fault, though you may have done something","cursed with the internal state of the sdk to specifically cause this.","If you see this error and you're quite sure you've just used the sdk","normally and as intended, you should really contact the Axel team."])}const Z={ethereum:{type:"mainnet",chain_id:c("0x1")},goerli:{type:"testnet",chain_id:c("0x5"),mainnet:"ethereum"},kovan:{type:"testnet",chain_id:c("0x2a"),mainnet:"ethereum"},rinkeby:{type:"testnet",chain_id:c("0x4"),mainnet:"ethereum"},ropsten:{type:"testnet",chain_id:c("0x3"),mainnet:"ethereum"}};for(const e of f(Z))g(Z[e]);function ee(e){return V(e)?Z[e].forks:e}const te=G,ne=function(e){if(y.assert(e),m("name",$,e),m("chain_id",M,e),m("forks",K,e),function(e){return l([...L,...Y,...G],e)}(e.name))throw new o(["Tried to add a new externet (external chain) to the Axel SDK's known",`chains but ${a(e.name)} already exists!`,"AxelClientInstance#add_chain({",`   name: ${a(e.name)},`,`   chain_id: ${a(e.chain_id)},`,`   forks: ${a(e.forks)},`,"});"]);var t;t=e.name,G.push(c(t)),function(e,t){const n={type:"externet",chain_id:c(t.chain_id),forks:t.forks};g(n),Z[e]=n}(e.name,e)};var oe=Object.freeze({__proto__:null,externets:te,add_externet:ne,mainnets:L,testnets:Y,internets:W}),se=Object.freeze({__proto__:null,AxelError:o,AxelTypeError:s});const re=["provider_connect","provider_disconnect","accounts_update","chain_update"];g(re);const ae=d(re,"event_name");var ie=Object.freeze({__proto__:null,names:re});const ce=["Gas priority is a floating point with a lower bound of 0 and an","upper bound of 2. Lower values indicate that you wish to use less","gas to complete your transaction."],ue={assert(e){if("number"!=typeof e)throw new s(["Input is not of type number!",...ce]);if(Number.isNaN(e))throw new s(["Input cannot be NaN!",...ce]);if(e<0)throw new s(["Input is too low!",...ce]);if(e>2)throw new s(["Input is too high!",...ce])},typename:"gas_priority"};function he(e){return ue.assert(e),e}const le={low:he(0),medium:he(1),high:he(2)},pe=le.low,de=le.medium,fe=le.high;var ye=Object.freeze({__proto__:null,low:pe,medium:de,high:fe}),we=Object.freeze({__proto__:null});const _e={auto:{action_class:["exchanging"],supported_chains:["ethereum"]},aave:{action_class:["lending"],supported_chains:["ethereum","kovan"]},balancer:{action_class:["exchanging"],supported_chains:["ethereum"]},compound:{action_class:["lending"],supported_chains:["ethereum","rinkeby"]},curve:{action_class:["exchanging"],supported_chains:["ethereum"]},lido:{action_class:["staking"],supported_chains:["ethereum","goerli"]},maker:{action_class:["lending"],supported_chains:["ethereum"]},oneinch:{action_class:["exchanging"],supported_chains:["ethereum"]},quickswap:{action_class:["exchanging"],supported_chains:["ethereum"]},rari:{action_class:["lending"],supported_chains:["ethereum"]},rocketpool:{action_class:["staking"],supported_chains:["ethereum"]},sushiswap:{action_class:["exchanging"],supported_chains:["ethereum"]},uniswap:{action_class:["exchanging"],supported_chains:["ethereum"]},yearn:{action_class:["yielding"],supported_chains:["ethereum"]}};g(_e);for(const e of f(_e)){const t=_e[e];g(t),g(t.action_class),g(t.supported_chains)}function me(e){const t=f(_e).filter((t=>l(_e[t].action_class,e))),n=`${e}_protocol`;return{assert(e){p(t,n,e)},typename:n}}const be=d(f(_e),"protocol");function ve(e,t){return l(_e[e].supported_chains,t)}const ge=me("lending"),xe=me("staking"),ke=me("yielding"),Te=me("exchanging"),$e={lending:ge,staking:xe,yielding:ke,exchanging:Te};const Ee=function(e,t){return be.assert(e),K.assert(t),ve(e,t)},Ae=function(e){const t=function(e){if(null!=e||(e={}),"object"!=typeof e)throw new s(["Could not assert that value is non-null object because of runtime type mismatch!",`typeof value was ${a(typeof e)} instead of "object".`]);return u(e)}(e);return b("chain",K,t),b("action_class",C,t),function({chain:e,action_class:t}){let n=[...f(_e)];return null!=e&&(n=n.filter((t=>l(_e[t].supported_chains,e)))),null!=t&&(n=n.filter((e=>l(_e[e].action_class,t)))),n}(t)};var je=Object.freeze({__proto__:null,supports_chain:Ee,filter_by:Ae,info:_e});const Pe={ETH:{type:"native"},DAI:{type:"erc20",redemption:!1},USDC:{type:"erc20",redemption:!1},aWETH:{type:"erc20",redemption:!0},cETH:{type:"erc20",redemption:!0},rETH:{type:"erc20",redemption:!0},stETH:{type:"erc20",redemption:!0},yvWETH:{type:"erc20",redemption:!0},aUSDC:{type:"erc20",redemption:!0},cUSDC:{type:"erc20",redemption:!0}};g(Pe);const Oe=f(Pe),Ie=d(Oe,"token"),Ce=x(Pe,"type","native"),qe=x(Pe,"redemption",!0),Ue=x(Pe,"type","erc20"),De={ethereum:"ETH",kovan:"ETH",rinkeby:"ETH",ropsten:"ETH",goerli:"ETH"};g(De);var Be=Object.freeze({__proto__:null,all:Oe,erc20:Ue,native:Ce,redemption:qe,from_internet:De});function Re(e){return new Promise((t=>{setTimeout(t,1e3*e)}))}function Se(e){return JSON.stringify(e)}const He={assert(e){try{M.assert(e)}catch(e){throw e instanceof s?new s(["Tried to convert input to hex_string since address Is-A hex_string but an error was thrown:",e]):e}if(42!==e.length)throw new s(['An address is a 42 character hexadecimal string beginning with "0x".',"e.g. 0x2170ed0880ac9a755fd29b2688956bd959f933f8","Your input was a hexadecimal string but it was the wrong length.",`input.length is ${e.length} instead of 42`,`input was ${a(e)}`])},typename:"address"};function Ne(e){if(null===e.provider)throw new o(["You are not connected to a provider.","Have you done AxelClientInstance#connect?"])}const ze={assert(e){O.assert(e),e.forEach(Me.assert)},typename:`array of ${(Me=He).typename}`};var Me;const Fe=j(1),Le=j(30),Ye=le.medium;var We=Object.freeze({__proto__:null,transaction_looker:class{constructor(e,t,n=Fe){this.client=e,this.tx_hash=t,this.poll_rate=n}async wait(){for(Ne(this.client);;){const e=await this.client.provider.request({method:"eth_getTransactionReceipt",params:[this.tx_hash]});if(null!=e)return e;await Re(this.poll_rate)}}}}),Ke=Object.freeze({__proto__:null});const Ge="Consider reviewing the docs at dox.axelapi.xyz/types/api_key",Ve={b:"bot",t:"test",u:"user"},Xe={assert(e){if("string"!=typeof e)throw new s(["API Key was not of type string!","Your api key is a string beginning with 'axl'.","If you don't have one yet, you can get one in the 'API Keys'","section of the Axel dashboard.",Ge]);if("axl"!==e.slice(0,3))throw new s([`Could not cast "${e}" to api_key`,"Your api key must begin with 'axl'.",Ge]);const t=e[3];if(!Object.keys(Ve).includes(t))throw new s(["Unrecognized key type!",`${e.slice(0,4)} <- '${t}'`,"If you copied this directly from the dashboard, your SDK may be too old!","Perhaps the server has been updated with a new key type. This is quite unlikely, though.","There are three supported API key types:","b - bot","t - test","u - user"]);if("-"!==e[4])throw new s(["Expected a hyphen/dash after Axel key identifier!",`${e}`,"    ^ < < < expected a hyphen there"]);if("0"!==e[5])throw new s(["This SDK only supports version 0 key types!"])},typename:"api_key"},Je={assert(e){if(y.assert(e),m("method",$,e),!w("params",e))return;let t,n;try{return void O.assert(e.params)}catch(e){if(!(e instanceof s))throw e;t=e}try{return void y.assert(e.params)}catch(e){if(!(e instanceof s))throw e;n=e}throw new s(["Tried to assert that value was of type EIP_1193.RequestArguments.","The value satisfied {method: string} but was unable to satisfy","{params?: readonly unknown[] | object}.",n,t])},typename:"EIP_1193.RequestArguments"},Qe={assert(e){if(!(e instanceof Error))throw new s(["A ProviderRpcError must extend Error!"]);m("code",E,e)},typename:"EIP_1193.ProviderRpcError"},Ze={assert(e){try{y.assert(e)}catch(e){throw e instanceof s?new s(["An error was encountered while validating the provider:",e]):e}try{_("request",e)}catch(e){throw new s(["While a provider without a .request method can technically be valid","so long as it has either one of a .send or a .sendAsync method.","This sdk makes extensive use of the .request method and therefore will not","allow you to pass in this provider, even if it *may* technically be valid.","See https://eips.ethereum.org/EIPS/eip-1193"])}b("isMetaMask",T,e),b("isCoinbaseWallet",T,e),v("on",k,e),v("removeListener",k,e),v("request",k,e)},typename:"EIP_1193_Provider"};function et(e){const t={provider_connect:[],provider_disconnect:[],chain_update:[],accounts_update:[]};function n(e,n){for(const o of t[e])try{h(o)(n)}catch(e){console.error(e)}}function r(e){try{ze.assert(e)}catch(e){return void n("accounts_update",{status:"error",error:i(e)})}n("accounts_update",{status:"ok",accounts:e})}function a(e){try{M.assert(e)}catch(e){return void n("chain_update",{status:"error",error:i(e)})}if(function(e){const t=f(Z).map((e=>Z[e].chain_id));return n=e,t.includes(n);var n}(e)){n("chain_update",{status:"known",chain:Q(e),chain_id:e})}else n("chain_update",{status:"unknown",chain:null,chain_id:e})}function c(e){n("provider_connect",void 0)}function l(e){try{Qe.assert(e)}catch(e){return void console.error(e)}n("provider_disconnect",e)}e.on=function(e,n){ae.assert(e),k.assert(n),function(e,n){t[e].push(n)}(e,u(n))},e.off=function(e,n){return ae.assert(e),k.assert(n),function(e,n){return function(e,t){const n=e.indexOf(t);return-1!==n&&(function(e,t){t.splice(e,1)[0]}(n,e),!0)}(t[e],n)}(e,n)},e.connect=async function(){const t=await async function(e){if(e)return Ze.assert(e),e;const t=globalThis.window;try{y.assert(t)}catch(e){throw e instanceof s?"undefined"==typeof process?new s([`Could not assert that window was a ${y.typename}.`,e]):new o(["process global exists which implies that this library is being run in NodeJS.","As such, you must provide your own eip-1193 provider.","There are no users to inject an ExternalProvider into globalThis.ethereum.","To provide your own ExternalProvider, please see the Ethereum documentation:","https://docs.ethers.io/v5/api/providers/other/#Web3Provider--ExternalProvider","This sdk will specifically check for the existence of a .send function"]):e}try{_("ethereum",t)}catch(e){throw e instanceof s?new o(["Tried to connect to a web3 provider but window.ethereum","was not present. Does your user have a wallet installed?",e]):e}try{Ze.assert(t.ethereum)}catch(e){throw e instanceof s?new s(["window.ethereum exists but is not a valid ExternalProvider:",e]):e}return t.ethereum}();t.on("accountsChanged",r),t.on("chainChanged",a),t.on("connect",c),t.on("disconnect",l),a(await t.request({method:"eth_chainId"})),r(await t.request({method:"eth_requestAccounts"})),e.provider=t}}const tt="https://api.axelapi.xyz/v0",nt={assert(e){try{y.assert(e),m("ok",T,e),!1===e.ok&&m("msg",$,e)}catch(e){throw e instanceof s?new s(["While asserting that input was a basic_response, an error was thrown:",e]):e}},typename:"basic_response"};var ot="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{},st={exports:{}};async function rt(e,t,n){let r;r=null!=n?function(e){const t=f(e);return 0===t.length?"":`?${t.map((t=>`${t}=${e[t]}`)).join("&")}`}(n):"";const a=`${tt}/${e}${r}`,i=await st.exports.fetch(a,{method:"GET",headers:{Accept:"application/json","X-API-KEY":t,"User-Agent":"@axelapi/sdk"}}),c=await i.json();try{nt.assert(c)}catch(e){throw e instanceof s?new o(["This is probably not your fault.","The server has returned an object which did not have a .ok key of type boolean.","Regardless of the http status response, all valid endpoints should conform","to this response structure.","Please contact the Axel developers immediately with this error message.",`url  = ${a}`,`data = ${Se(c)}`,e]):e}if(i.status<100)throw new o(["This is probably not your fault.",`The server responded with ${i.status}. Is that even possible?`,"Well, if you're seeing this, something quite wrong has happened.","Please contact the Axel developers with this error message.",`url  = ${a}`,`data = ${Se(c)}`]);if(i.status<200)throw new o(["Unable to handle 1xx http responses."]);if(i.status<300){if(c.ok)return c;throw new o(["This is probably not your fault.",`The status of the request is ${i.status} but the server returned`,"a response where ok = false. This does not make sense.","Please contact the Axel developers with this error message.",`url  = ${a}`,`data = ${Se(c)}`])}if(i.status<400)throw new o(["Unable to handle 3xx http responses."]);if(i.status<500){if(c.ok)throw new o(["This is probably not your fault.",`The status of the request is ${i.status} but the server returned`,"a response where ok = true. This does not make sense.","Please contact the Axel developers with this error message.",`url  = ${a}`,`data = ${Se(c)}`]);throw new o([`${i.status} ${i.statusText}`,c.msg])}if(i.status<600){if(c.ok)throw new o(["This is probably not your fault.",`The status of the request is ${i.status} but the server returned`,"a response where ok = true. This does not make sense.","Please contact the Axel developers with this error message.",`url  = ${a}`,`data = ${Se(c)}`]);throw new o([`${i.status} ${i.statusText}`,c.msg])}throw new o([`Unable to handle http code ${i.status}!`])}async function at(e,t,n){const r=`${tt}/${e}`,a=await st.exports.fetch(r,{method:"POST",body:Se(n),headers:{Accept:"application/json","Content-Type":"application/json","X-API-KEY":t,"User-Agent":"@axelapi/sdk"}}),i=await a.json();try{nt.assert(i)}catch(e){throw e instanceof s?new o(["This is probably not your fault.","The server has returned an object which did not have a .ok key of type boolean.","Regardless of the http status response, all valid endpoints should conform","to this response structure.","Please contact the Axel developers immediately with this error message.",`url  = ${r}`,`body = ${Se(n)}`,`data = ${Se(i)}`,e]):e}if(a.status<100)throw new o(["This is probably not your fault.",`The server responded with ${a.status}. Is that even possible?`,"Well, if you're seeing this, something quite wrong has happened.","Please contact the Axel developers with this error message.",`url  = ${r}`,`body = ${Se(n)}`,`data = ${Se(i)}`]);if(a.status<200)throw new o(["Unable to handle 1xx http responses."]);if(a.status<300){if(i.ok)return i;throw new o(["This is probably not your fault.",`The status of the request is ${a.status} but the server returned`,"a response where ok = false. This does not make sense.","Please contact the Axel developers with this error message.",`url  = ${r}`,`body = ${Se(n)}`,`data = ${Se(i)}`])}if(a.status<400)throw new o(["Unable to handle 3xx http responses."]);if(a.status<500){if(i.ok)throw new o(["This is probably not your fault.",`The status of the request is ${a.status} but the server returned`,"a response where ok = true. This does not make sense.","Please contact the Axel developers with this error message.",`url  = ${r}`,`body = ${Se(n)}`,`data = ${Se(i)}`]);throw new o([`${a.status} ${a.statusText}`,i.msg])}if(a.status<600){if(i.ok)throw new o(["This is probably not your fault.",`The status of the request is ${a.status} but the server returned`,"a response where ok = true. This does not make sense.","Please contact the Axel developers with this error message.",`url  = ${r}`,`body = ${Se(n)}`,`data = ${Se(i)}`]);throw new o([`${a.status} ${a.statusText}`,i.msg])}throw new o([`Unable to handle http code ${a.status}!`])}!function(e,t){var n="undefined"!=typeof self?self:ot,o=function(){function e(){this.fetch=!1,this.DOMException=n.DOMException}return e.prototype=n,new e}();!function(e){!function(t){var n="URLSearchParams"in e,o="Symbol"in e&&"iterator"in Symbol,s="FileReader"in e&&"Blob"in e&&function(){try{return new Blob,!0}catch(e){return!1}}(),r="FormData"in e,a="ArrayBuffer"in e;if(a)var i=["[object Int8Array]","[object Uint8Array]","[object Uint8ClampedArray]","[object Int16Array]","[object Uint16Array]","[object Int32Array]","[object Uint32Array]","[object Float32Array]","[object Float64Array]"],c=ArrayBuffer.isView||function(e){return e&&i.indexOf(Object.prototype.toString.call(e))>-1};function u(e){if("string"!=typeof e&&(e=String(e)),/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(e))throw new TypeError("Invalid character in header field name");return e.toLowerCase()}function h(e){return"string"!=typeof e&&(e=String(e)),e}function l(e){var t={next:function(){var t=e.shift();return{done:void 0===t,value:t}}};return o&&(t[Symbol.iterator]=function(){return t}),t}function p(e){this.map={},e instanceof p?e.forEach((function(e,t){this.append(t,e)}),this):Array.isArray(e)?e.forEach((function(e){this.append(e[0],e[1])}),this):e&&Object.getOwnPropertyNames(e).forEach((function(t){this.append(t,e[t])}),this)}function d(e){if(e.bodyUsed)return Promise.reject(new TypeError("Already read"));e.bodyUsed=!0}function f(e){return new Promise((function(t,n){e.onload=function(){t(e.result)},e.onerror=function(){n(e.error)}}))}function y(e){var t=new FileReader,n=f(t);return t.readAsArrayBuffer(e),n}function w(e){if(e.slice)return e.slice(0);var t=new Uint8Array(e.byteLength);return t.set(new Uint8Array(e)),t.buffer}function _(){return this.bodyUsed=!1,this._initBody=function(e){var t;this._bodyInit=e,e?"string"==typeof e?this._bodyText=e:s&&Blob.prototype.isPrototypeOf(e)?this._bodyBlob=e:r&&FormData.prototype.isPrototypeOf(e)?this._bodyFormData=e:n&&URLSearchParams.prototype.isPrototypeOf(e)?this._bodyText=e.toString():a&&s&&((t=e)&&DataView.prototype.isPrototypeOf(t))?(this._bodyArrayBuffer=w(e.buffer),this._bodyInit=new Blob([this._bodyArrayBuffer])):a&&(ArrayBuffer.prototype.isPrototypeOf(e)||c(e))?this._bodyArrayBuffer=w(e):this._bodyText=e=Object.prototype.toString.call(e):this._bodyText="",this.headers.get("content-type")||("string"==typeof e?this.headers.set("content-type","text/plain;charset=UTF-8"):this._bodyBlob&&this._bodyBlob.type?this.headers.set("content-type",this._bodyBlob.type):n&&URLSearchParams.prototype.isPrototypeOf(e)&&this.headers.set("content-type","application/x-www-form-urlencoded;charset=UTF-8"))},s&&(this.blob=function(){var e=d(this);if(e)return e;if(this._bodyBlob)return Promise.resolve(this._bodyBlob);if(this._bodyArrayBuffer)return Promise.resolve(new Blob([this._bodyArrayBuffer]));if(this._bodyFormData)throw new Error("could not read FormData body as blob");return Promise.resolve(new Blob([this._bodyText]))},this.arrayBuffer=function(){return this._bodyArrayBuffer?d(this)||Promise.resolve(this._bodyArrayBuffer):this.blob().then(y)}),this.text=function(){var e,t,n,o=d(this);if(o)return o;if(this._bodyBlob)return e=this._bodyBlob,t=new FileReader,n=f(t),t.readAsText(e),n;if(this._bodyArrayBuffer)return Promise.resolve(function(e){for(var t=new Uint8Array(e),n=new Array(t.length),o=0;o<t.length;o++)n[o]=String.fromCharCode(t[o]);return n.join("")}(this._bodyArrayBuffer));if(this._bodyFormData)throw new Error("could not read FormData body as text");return Promise.resolve(this._bodyText)},r&&(this.formData=function(){return this.text().then(v)}),this.json=function(){return this.text().then(JSON.parse)},this}p.prototype.append=function(e,t){e=u(e),t=h(t);var n=this.map[e];this.map[e]=n?n+", "+t:t},p.prototype.delete=function(e){delete this.map[u(e)]},p.prototype.get=function(e){return e=u(e),this.has(e)?this.map[e]:null},p.prototype.has=function(e){return this.map.hasOwnProperty(u(e))},p.prototype.set=function(e,t){this.map[u(e)]=h(t)},p.prototype.forEach=function(e,t){for(var n in this.map)this.map.hasOwnProperty(n)&&e.call(t,this.map[n],n,this)},p.prototype.keys=function(){var e=[];return this.forEach((function(t,n){e.push(n)})),l(e)},p.prototype.values=function(){var e=[];return this.forEach((function(t){e.push(t)})),l(e)},p.prototype.entries=function(){var e=[];return this.forEach((function(t,n){e.push([n,t])})),l(e)},o&&(p.prototype[Symbol.iterator]=p.prototype.entries);var m=["DELETE","GET","HEAD","OPTIONS","POST","PUT"];function b(e,t){var n,o,s=(t=t||{}).body;if(e instanceof b){if(e.bodyUsed)throw new TypeError("Already read");this.url=e.url,this.credentials=e.credentials,t.headers||(this.headers=new p(e.headers)),this.method=e.method,this.mode=e.mode,this.signal=e.signal,s||null==e._bodyInit||(s=e._bodyInit,e.bodyUsed=!0)}else this.url=String(e);if(this.credentials=t.credentials||this.credentials||"same-origin",!t.headers&&this.headers||(this.headers=new p(t.headers)),this.method=(n=t.method||this.method||"GET",o=n.toUpperCase(),m.indexOf(o)>-1?o:n),this.mode=t.mode||this.mode||null,this.signal=t.signal||this.signal,this.referrer=null,("GET"===this.method||"HEAD"===this.method)&&s)throw new TypeError("Body not allowed for GET or HEAD requests");this._initBody(s)}function v(e){var t=new FormData;return e.trim().split("&").forEach((function(e){if(e){var n=e.split("="),o=n.shift().replace(/\+/g," "),s=n.join("=").replace(/\+/g," ");t.append(decodeURIComponent(o),decodeURIComponent(s))}})),t}function g(e,t){t||(t={}),this.type="default",this.status=void 0===t.status?200:t.status,this.ok=this.status>=200&&this.status<300,this.statusText="statusText"in t?t.statusText:"OK",this.headers=new p(t.headers),this.url=t.url||"",this._initBody(e)}b.prototype.clone=function(){return new b(this,{body:this._bodyInit})},_.call(b.prototype),_.call(g.prototype),g.prototype.clone=function(){return new g(this._bodyInit,{status:this.status,statusText:this.statusText,headers:new p(this.headers),url:this.url})},g.error=function(){var e=new g(null,{status:0,statusText:""});return e.type="error",e};var x=[301,302,303,307,308];g.redirect=function(e,t){if(-1===x.indexOf(t))throw new RangeError("Invalid status code");return new g(null,{status:t,headers:{location:e}})},t.DOMException=e.DOMException;try{new t.DOMException}catch(e){t.DOMException=function(e,t){this.message=e,this.name=t;var n=Error(e);this.stack=n.stack},t.DOMException.prototype=Object.create(Error.prototype),t.DOMException.prototype.constructor=t.DOMException}function k(e,n){return new Promise((function(o,r){var a=new b(e,n);if(a.signal&&a.signal.aborted)return r(new t.DOMException("Aborted","AbortError"));var i=new XMLHttpRequest;function c(){i.abort()}i.onload=function(){var e,t,n={status:i.status,statusText:i.statusText,headers:(e=i.getAllResponseHeaders()||"",t=new p,e.replace(/\r?\n[\t ]+/g," ").split(/\r?\n/).forEach((function(e){var n=e.split(":"),o=n.shift().trim();if(o){var s=n.join(":").trim();t.append(o,s)}})),t)};n.url="responseURL"in i?i.responseURL:n.headers.get("X-Request-URL");var s="response"in i?i.response:i.responseText;o(new g(s,n))},i.onerror=function(){r(new TypeError("Network request failed"))},i.ontimeout=function(){r(new TypeError("Network request failed"))},i.onabort=function(){r(new t.DOMException("Aborted","AbortError"))},i.open(a.method,a.url,!0),"include"===a.credentials?i.withCredentials=!0:"omit"===a.credentials&&(i.withCredentials=!1),"responseType"in i&&s&&(i.responseType="blob"),a.headers.forEach((function(e,t){i.setRequestHeader(t,e)})),a.signal&&(a.signal.addEventListener("abort",c),i.onreadystatechange=function(){4===i.readyState&&a.signal.removeEventListener("abort",c)}),i.send(void 0===a._bodyInit?null:a._bodyInit)}))}k.polyfill=!0,e.fetch||(e.fetch=k,e.Headers=p,e.Request=b,e.Response=g),t.Headers=p,t.Request=b,t.Response=g,t.fetch=k,Object.defineProperty(t,"__esModule",{value:!0})}({})}(o),o.fetch.ponyfill=!0,delete o.fetch.polyfill;var s=o;(t=s.fetch).default=s.fetch,t.fetch=s.fetch,t.Headers=s.Headers,t.Request=s.Request,t.Response=s.Response,e.exports=t}(st,st.exports);const it={assert(e){m("gas",M,e)},typename:"gas_res"};function ct(e,t,n,s){if("externet"===Z[t].type){if(!ve(e,n))throw new o([`Tried to ${s} but protocol ${a(e)} does not support`,`chain ${a(t)} because it does not support it's parent chain ${a(n)}.`])}else{if(t!==n)throw new o(["Logic Error: src/core/client::check_protocol","Please repor this to the Axel developers immediately."]);if(!ve(e,n))throw new o([`Tried to ${s} but protocol ${a(e)}`,`does not support chain ${a(n)}`])}}async function ut(e,t,n){const s=Z[t].chain_id;try{await e.provider.request({method:"wallet_switchEthereumChain",params:[{chainId:s}]})}catch(e){throw new o(["User did not want to switch chains!",`Tried switching to "${s}"`])}const r=await e.provider.request(n);return M.assert(r),r}async function ht(e,t){ct(t.protocol,t.client_chain,t.chain,"exchanging");const n=await at("exchange",e.api_key,t);return function(e){m("rpc_request",Je,e)}(n),ut(e,t.client_chain,n.rpc_request)}async function lt(e,t){const n=ee(t.chain),o=await at("balance",e.api_key,{...t,chain:n});!function(e){m("rpc_request",Je,e),m("decimals",A,e)}(o);const s=await e.provider.request(o.rpc_request);M.assert(s);return F(s,o.decimals)}function pt(e,t){y.assert(e),m("amount",P,e),m("protocol",t,e),b("chain",X,e),b("token",Ie,e),b("wallet_address",He,e),b("gas_priority",ue,e),b("minutes_timeout",A,e)}async function dt(e,t){var n,o,r,a,i;const c=t.amount,u=t.protocol,h=null!==(n=t.chain)&&void 0!==n?n:await e.get_chain(),l=ee(h),p=null!==(o=t.token)&&void 0!==o?o:De[l],d=null!==(r=t.wallet_address)&&void 0!==r?r:await e.get_account();if(null===d)throw new s(["You did not supply a wallet_address and the sdk could not infer one.","Have you called AxelClientInstance#connect?"]);return{amount:c,protocol:u,client_chain:h,chain:l,token:p,wallet_address:d,gas_priority:null!==(a=t.gas_priority)&&void 0!==a?a:Ye,minutes_timeout:null!==(i=t.minutes_timeout)&&void 0!==i?i:Le}}async function ft(e,t,n){ct(n.protocol,n.client_chain,n.chain,t);const o=await at(t,e.api_key,n);return m("rpc_request",Je,o),ut(e,n.client_chain,o.rpc_request)}const yt=q.borrow.action_class,wt=$e[yt];const _t=q.deposit.action_class,mt=$e[_t];const bt=q.lend.action_class,vt=$e[bt];const gt=q.stake.action_class,xt=$e[gt];const kt=q.supply.action_class,Tt=$e[kt];const $t=q.unborrow.action_class,Et=$e[$t];const At=q.undeposit.action_class,jt=$e[At];const Pt=q.unlend.action_class,Ot=$e[Pt];const It=q.unstake.action_class,Ct=$e[It];const qt=q.unsupply.action_class,Ut=$e[qt];function Dt(e){if(!new.target)throw new s(["You must instantiate AxelClientInstance (AxelCoreClient internally)","using 'new'!","",'const {Client} = require("@axelapi/sdk");','const axel = new Client("axlu-0-your-api-key")',"             ~~~","Did you forget this?"]);Xe.assert(e),this.api_key=e,this.provider=null,et(this)}Dt.prototype.get_accounts=async function(){if(null===this.provider)return[];const e=await this.provider.request({method:"eth_accounts"});return ze.assert(e),e},Dt.prototype.get_account=async function(){const e=await this.get_accounts();return 0===e.length?null:e[0]},Dt.prototype.get_chain_id=async function(){if(null===this.provider)return null;const e=await this.provider.request({method:"eth_chainId"});try{M.assert(e)}catch(e){throw e instanceof s?new s(["eth_chainId returned something that did not satisfy hex_string!",e]):e}return e},Dt.prototype.get_chain=async function(){const e=await this.get_chain_id();if(null===e)return null;try{J.assert(e)}catch(t){throw t instanceof s?new s(["You are on an unknown chain!",`chain_id = "${e}"`,t]):t}return Q(e)},Dt.prototype.unsafe_estimate_gas=async function(e){const t=await rt("gas",this.api_key,{chain:e});return it.assert(t),t.gas},Dt.prototype.estimate_gas=async function(e){return null!=e||(e=await this.get_chain()),X.assert(e),this.unsafe_estimate_gas(e)},Dt.prototype.unsafe_exchange=function(e){return Ne(this),ht(this,e)},Dt.prototype.exchange=async function(e){var t;return Ne(this),t=e,y.assert(t),m("sell_amount",P,t),m("sell_token",Ie,t),m("buy_token",Ie,t),b("protocol",Te,t),b("chain",X,t),b("wallet_address",He,t),b("gas_priority",ue,t),b("minutes_timeout",A,t),ht(this,await async function(e,t){var n,o,r,a,i;const c=t.sell_amount,u=t.sell_token,h=t.buy_token,l=null!==(n=t.protocol)&&void 0!==n?n:"auto",p=null!==(o=t.chain)&&void 0!==o?o:await e.get_chain(),d=ee(p),f=null!==(r=t.wallet_address)&&void 0!==r?r:await e.get_account();if(null===f)throw new s(["You did not supply a wallet_address and the sdk could not infer one.","Have you called AxelClientInstance#connect?"]);return{sell_amount:c,sell_token:u,buy_token:h,protocol:l,client_chain:p,chain:d,wallet_address:f,gas_priority:null!==(a=t.gas_priority)&&void 0!==a?a:le.medium,minutes_timeout:null!==(i=t.minutes_timeout)&&void 0!==i?i:Le}}(this,e))},Dt.prototype.unsafe_get_apy=async function(e,t){const n=await rt(`apy_${e}`,this.api_key,t);return function(e){m("apy",P,e)}(n),n.apy},Dt.prototype.get_apy=async function(e,t){!function(e,t){y.assert(t),m("protocol",$e[S[e]],t),b("chain",K,t),b("token",Ie,t)}(e,t);const n=await async function(e,t){var n,o;const r=t.protocol,a=null!==(n=t.chain)&&void 0!==n?n:await e.get_chain();if(null===a)throw new s(["You did not provide a chain and we could not infer one from the provider.","The provider is not connected"]);if(V(a))throw new s([`You did not provide a chain so it defaulted to the currently chain, "${a}".`,"Unfortunately, this chain is not supported by APY family functions."]);return{protocol:r,chain:a,token:null!==(o=t.token)&&void 0!==o?o:De[a]}}(this,t);return this.unsafe_get_apy(e,n)},Dt.prototype.unsafe_get_balance=function(e){return Ne(this),lt(this,e)},Dt.prototype.get_balance=async function(e={}){var t;return Ne(this),t=e,y.assert(t),b("chain",X,t),b("token",Ie,t),b("wallet_address",He,t),lt(this,await async function(e,t){var n,o,r;const a=null!==(n=t.chain)&&void 0!==n?n:await e.get_chain(),i=ee(a),c=null!==(o=t.token)&&void 0!==o?o:De[i],u=null!==(r=t.wallet_address)&&void 0!==r?r:await e.get_account();if(null===u)throw new s(["You did not supply a wallet_address and the sdk could not infer one.","Have you called AxelClientInstance#connect?"]);return{client_chain:a,chain:i,token:c,wallet_address:u}}(this,e))},Dt.prototype.unsafe_borrow=function(e){return Ne(this),ft(this,"borrow",e)},Dt.prototype.borrow=async function(e){return Ne(this),pt(e,wt),ft(this,"borrow",await dt(this,e))},Dt.prototype.unsafe_deposit=function(e){return Ne(this),ft(this,"deposit",e)},Dt.prototype.deposit=async function(e){return Ne(this),pt(e,mt),ft(this,"deposit",await dt(this,e))},Dt.prototype.unsafe_lend=function(e){return Ne(this),ft(this,"lend",e)},Dt.prototype.lend=async function(e){return Ne(this),pt(e,vt),ft(this,"lend",await dt(this,e))},Dt.prototype.unsafe_stake=function(e){return Ne(this),ft(this,"stake",e)},Dt.prototype.stake=async function(e){return Ne(this),pt(e,xt),ft(this,"stake",await dt(this,e))},Dt.prototype.unsafe_supply=function(e){return Ne(this),ft(this,"supply",e)},Dt.prototype.supply=async function(e){return Ne(this),pt(e,Tt),ft(this,"supply",await dt(this,e))},Dt.prototype.unsafe_unborrow=function(e){return Ne(this),ft(this,"unborrow",e)},Dt.prototype.unborrow=async function(e){return Ne(this),pt(e,Et),ft(this,"unborrow",await dt(this,e))},Dt.prototype.unsafe_undeposit=function(e){return Ne(this),ft(this,"undeposit",e)},Dt.prototype.undeposit=async function(e){return Ne(this),pt(e,jt),ft(this,"undeposit",await dt(this,e))},Dt.prototype.unsafe_unlend=function(e){return Ne(this),ft(this,"unlend",e)},Dt.prototype.unlend=async function(e){return Ne(this),pt(e,Ot),ft(this,"unlend",await dt(this,e))},Dt.prototype.unsafe_unstake=function(e){return Ne(this),ft(this,"unstake",e)},Dt.prototype.unstake=async function(e){return Ne(this),pt(e,Ct),ft(this,"unstake",await dt(this,e))},Dt.prototype.unsafe_unsupply=function(e){return Ne(this),ft(this,"unsupply",e)},Dt.prototype.unsupply=async function(e){return Ne(this),pt(e,Ut),ft(this,"unsupply",await dt(this,e))};const Bt=i(Dt);e.Client=Bt,e.EIP_1193=Ke,e.actions=D,e.address=B,e.api_key=R,e.apy=H,e.chains=oe,e.err=se,e.events=ie,e.gas_priority=ye,e.hex_string=we,e.lookers=We,e.protocols=je,e.tokens=Be,Object.defineProperty(e,"__esModule",{value:!0})}));