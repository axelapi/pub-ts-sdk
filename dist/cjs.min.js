"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e,t=require("cross-fetch");function n(e,t,n,s){if("a"===n&&!s)throw new TypeError("Private accessor was defined without a getter");if("function"==typeof t?e!==t||!s:!t.has(e))throw new TypeError("Cannot read private member from an object whose class did not declare it");return"m"===n?s:"a"===n?s.call(e):s?s.value:t.get(e)}class s extends Error{constructor(t){const o=[""];for(const a of t)if(a instanceof s)for(const t of n(a,e,"f"))o.push(`> > ${t}`);else o.push(`> ${a}`);super(o.join("\n")),e.set(this,void 0),function(e,t,n,s,o){if("m"===s)throw new TypeError("Private method is not writable");if("a"===s&&!o)throw new TypeError("Private accessor was defined without a setter");if("function"==typeof t?e!==t||!o:!t.has(e))throw new TypeError("Cannot write private member to an object whose class did not declare it");"a"===s?o.call(e,n):o?o.value=n:t.set(e,n)}(this,e,o,"f")}}e=new WeakMap;class o extends s{constructor(e){super(e)}}const a=e=>e;function r(e){return"string"==typeof e?`"${e}"`:""+e}const i=a,c=i,u=a,h=a;function l(e,t){return u(e.includes(t))}function p(e,t,n){if(!e.includes(n))throw new o([`Could not assert that input is a ${t}!`,`elem was ${r(n)} but should have been one of the following:`,...e.map((e=>`- ${r(e)}`))])}function d(e,t){return{assert(n){p(e,t,n)},typename:t}}function f(e){const t=Object.keys(e);return b(t),u(t)}const w={assert(e){if("object"!=typeof e)throw new o(["Could not assert that value is non-null object because of runtime type mismatch!",`typeof value was ${r(typeof e)} instead of "object".`]);if(null===e)throw new o(["Could not assert that value is non-null object because value was null!"])},typename:"non-null object"},y=(e,t)=>Object.hasOwnProperty.call(t,e);function _(e,t){if(!y(e,t))throw new o([`Object did not have key ${r(e)}!`])}function m(e,t,n){_(e,n);try{t.assert(n[e])}catch(n){throw n instanceof o?new o([`While asserting that object[${r(e)}] is of type ${t.typename}`,"an error was thrown:",n]):n}}function g(e,t,n){if(y(e,n))try{t.assert(n[e])}catch(n){if(n instanceof o)throw new o([`While asserting that object[${r(e)}] has optional value of type ${t.typename}`,"an error was thrown:",n])}}function v(e,t,n){!function(e,t){if(!(e in t))throw new o([`${r(e)} was not in Object!`])}(e,n);try{t.assert(n[e])}catch(n){throw n instanceof o?new o([`While asserting that object[${r(e)}] is of type ${t.typename}`,"an error was thrown:",n]):n}}function b(e){Object.freeze(e)}function k(e,t,n){return u(f(e).filter((s=>e[s][t]===u(n))))}const x={assert(e){if("function"!=typeof e)throw new o(["Could not assert that value is function because",`typeof value was ${r(typeof e)} instead of "function"!`])},typename:"any_fn"},$={assert(e){if("boolean"!=typeof e)throw new o(["Could not assert that value is boolean because",`typeof value was ${r(typeof e)} instead of "boolean"!`])},typename:"boolean"},T={assert(e){if("string"!=typeof e)throw new o(["Could not assert that value is string because",`typeof value was ${r(typeof e)} instead of "string"!`])},typename:"string"},j={assert(e){if("number"!=typeof e)throw new o(["Could not assert that value is number because",`typeof value was ${r(typeof e)} instead of "number"!`]);if(Number.isNaN(e))throw new o(["Could not assert that value is number because value was NaN!"])},typename:"number"},A={assert(e){if(!Number.isInteger(e))throw new o(["Could not assert that value is uint because value was not an integer!",`Value was ${e}.`]);if(e<0)throw new o(["Could not assert that value is uint because value was negative!",`Value was ${e}.`])},typename:"uint"};function E(e){return A.assert(e),e}const C={assert(e){if("number"!=typeof e)throw new o(["Could not assert that value is ufloat because",`typeof value was ${r(typeof e)} instead of "number"!`]);if(Number.isNaN(e))throw new o(["Could not assert that value is ufloat because value is NaN!"]);if(!Number.isFinite(e))throw new o([`Could not assert that value is ufloat because value is ${e}`]);if(e<0)throw new o(["Could not assert that value is ufloat because value is negative!",`Value was ${e}`])},typename:"ufloat"},P={assert(e){if(!Array.isArray(e))throw new o(["Could not assert that value is an array!"])},typename:"array"};const I=["lending","staking","yielding","exchanging"];b(I);const q=d(I,"action_class"),O={lend:{reverse:"unlend",action_class:"lending"},supply:{reverse:"unsupply",action_class:"lending"},borrow:{reverse:"unborrow",action_class:"lending"},stake:{reverse:"unstake",action_class:"staking"},deposit:{reverse:"undeposit",action_class:"yielding"},exchange:{reverse:"exchange",action_class:"exchanging"},unlend:{reverse:"lend",action_class:"lending"},unsupply:{reverse:"supply",action_class:"lending"},unborrow:{reverse:"borrow",action_class:"lending"},unstake:{reverse:"stake",action_class:"staking"},undeposit:{reverse:"deposit",action_class:"yielding"}};b(O);const N=f(O);var z=Object.freeze({__proto__:null,actions:N,info:O,classes:I}),H=Object.freeze({__proto__:null}),U=Object.freeze({__proto__:null});const Y={lend:"lending",borrow:"lending",stake:"staking",yield:"yielding"};b(Y),f(Y);var S=Object.freeze({__proto__:null,info:Y});const W=/^[0-9a-f]$/i,D=/^0x[0-9a-f]*$/i;const K={assert(e){if("string"!=typeof e)throw new o([`Input of type ${r(e)} is not of type "string" and therefore`,"cannot be a hex_string."]);if(!e.startsWith("0x"))throw new o(['String does not start with "0x".',`Instead started with "${e.slice(0,2)}".`,"Therefore it is not a hex_string."]);if(t=e,!D.test(t)){const t=[...e.slice(2)].map((e=>W.test(e)?" ":"?")).join("");throw new o(['String starts with "0x" which would indicate a hexadecimal string',"but the value specified is not in base 16",`input = "${e}"`,`           ${t}`])}var t},typename:"hex_string"};function R(e,t){return function(e,t){return u(e/10**t)}(function(e){const t=parseInt(e,16);return A.assert(t),t}(e),t)}const M=["ethereum"];b(M);const L=["kovan","rinkeby","ropsten","goerli"];b(L);const V=[...M,...L];b(V);const G=d(V,"internet"),J=[];function X(e){return l(J,e)}const F={assert(e){p([...M,...L,...J],"chain",e)},typename:"chain"};const B={assert(e){p(f(Z).map((e=>Z[e].chain_id)),"chain_id",e)},typename:"chain_id"};function Q(e){for(const t of f(Z)){if(Z[t].chain_id===e)return t}throw new s(["src/core/chains.ts::chain_id::to_chain","","If you have seen this, something has gone very, very wrong!","I am pretty sure this can never, ever happen but my assumptions have","been proven wrong before.","This is, *probably* not your fault, though you may have done something","cursed with the internal state of the sdk to specifically cause this.","If you see this error and you're quite sure you've just used the sdk","normally and as intended, you should really contact the Axel team."])}const Z={ethereum:{type:"mainnet",chain_id:c("0x1")},goerli:{type:"testnet",chain_id:c("0x5"),mainnet:"ethereum"},kovan:{type:"testnet",chain_id:c("0x2a"),mainnet:"ethereum"},rinkeby:{type:"testnet",chain_id:c("0x4"),mainnet:"ethereum"},ropsten:{type:"testnet",chain_id:c("0x3"),mainnet:"ethereum"}};for(const e of f(Z))b(Z[e]);function ee(e){return X(e)?Z[e].forks:e}const te=J,ne=function(e){if(w.assert(e),m("name",T,e),m("chain_id",K,e),m("forks",G,e),function(e){return l([...M,...L,...J],e)}(e.name))throw new s(["Tried to add a new externet (external chain) to the Axel SDK's known",`chains but ${r(e.name)} already exists!`,"AxelClientInstance#add_chain({",`   name: ${r(e.name)},`,`   chain_id: ${r(e.chain_id)},`,`   forks: ${r(e.forks)},`,"});"]);var t;t=e.name,J.push(c(t)),function(e,t){const n={type:"externet",chain_id:c(t.chain_id),forks:t.forks};b(n),Z[e]=n}(e.name,e)};var se=Object.freeze({__proto__:null,externets:te,add_externet:ne,mainnets:M,testnets:L,internets:V}),oe=Object.freeze({__proto__:null,AxelError:s,AxelTypeError:o});const ae=["provider_connect","provider_disconnect","accounts_update","chain_update"];b(ae);const re=d(ae,"event_name");var ie=Object.freeze({__proto__:null,names:ae});const ce=["Gas priority is a floating point with a lower bound of 0 and an","upper bound of 2. Lower values indicate that you wish to use less","gas to complete your transaction."],ue={assert(e){if("number"!=typeof e)throw new o(["Input is not of type number!",...ce]);if(Number.isNaN(e))throw new o(["Input cannot be NaN!",...ce]);if(e<0)throw new o(["Input is too low!",...ce]);if(e>2)throw new o(["Input is too high!",...ce])},typename:"gas_priority"};function he(e){return ue.assert(e),e}const le={low:he(0),medium:he(1),high:he(2)},pe=le.low,de=le.medium,fe=le.high;var we=Object.freeze({__proto__:null,low:pe,medium:de,high:fe}),ye=Object.freeze({__proto__:null});const _e={auto:{action_class:["exchanging"],supported_chains:["ethereum"]},aave:{action_class:["lending"],supported_chains:["ethereum","kovan"]},balancer:{action_class:["exchanging"],supported_chains:["ethereum"]},compound:{action_class:["lending"],supported_chains:["ethereum","rinkeby"]},curve:{action_class:["exchanging"],supported_chains:["ethereum"]},lido:{action_class:["staking"],supported_chains:["ethereum","goerli"]},maker:{action_class:["lending"],supported_chains:["ethereum"]},oneinch:{action_class:["exchanging"],supported_chains:["ethereum"]},quickswap:{action_class:["exchanging"],supported_chains:["ethereum"]},rari:{action_class:["lending"],supported_chains:["ethereum"]},rocketpool:{action_class:["staking"],supported_chains:["ethereum"]},sushiswap:{action_class:["exchanging"],supported_chains:["ethereum"]},uniswap:{action_class:["exchanging"],supported_chains:["ethereum"]},yearn:{action_class:["yielding"],supported_chains:["ethereum"]}};b(_e);for(const e of f(_e)){const t=_e[e];b(t),b(t.action_class),b(t.supported_chains)}function me(e){const t=f(_e).filter((t=>l(_e[t].action_class,e))),n=`${e}_protocol`;return{assert(e){p(t,n,e)},typename:n}}const ge=d(f(_e),"protocol");function ve(e,t){return l(_e[e].supported_chains,t)}const be=me("lending"),ke=me("staking"),xe=me("yielding"),$e=me("exchanging"),Te={lending:be,staking:ke,yielding:xe,exchanging:$e};const je=function(e,t){return ge.assert(e),G.assert(t),ve(e,t)},Ae=function(e){const t=function(e){if(null!=e||(e={}),"object"!=typeof e)throw new o(["Could not assert that value is non-null object because of runtime type mismatch!",`typeof value was ${r(typeof e)} instead of "object".`]);return u(e)}(e);return g("chain",G,t),g("action_class",q,t),function({chain:e,action_class:t}){let n=[...f(_e)];return null!=e&&(n=n.filter((t=>l(_e[t].supported_chains,e)))),null!=t&&(n=n.filter((e=>l(_e[e].action_class,t)))),n}(t)};var Ee=Object.freeze({__proto__:null,supports_chain:je,filter_by:Ae,info:_e});const Ce={ETH:{type:"native"},DAI:{type:"erc20",redemption:!1},USDC:{type:"erc20",redemption:!1},aWETH:{type:"erc20",redemption:!0},cETH:{type:"erc20",redemption:!0},rETH:{type:"erc20",redemption:!0},stETH:{type:"erc20",redemption:!0},yvWETH:{type:"erc20",redemption:!0},aUSDC:{type:"erc20",redemption:!0},cUSDC:{type:"erc20",redemption:!0}};b(Ce);const Pe=f(Ce),Ie=d(Pe,"token"),qe=k(Ce,"type","native"),Oe=k(Ce,"redemption",!0),Ne=k(Ce,"type","erc20"),ze={ethereum:"ETH",kovan:"ETH",rinkeby:"ETH",ropsten:"ETH",goerli:"ETH"};b(ze);var He=Object.freeze({__proto__:null,all:Pe,erc20:Ne,native:qe,redemption:Oe,from_internet:ze});function Ue(e){return new Promise((t=>{setTimeout(t,1e3*e)}))}function Ye(e){return JSON.stringify(e)}const Se={assert(e){try{K.assert(e)}catch(e){throw e instanceof o?new o(["Tried to convert input to hex_string since address Is-A hex_string but an error was thrown:",e]):e}if(42!==e.length)throw new o(['An address is a 42 character hexadecimal string beginning with "0x".',"e.g. 0x2170ed0880ac9a755fd29b2688956bd959f933f8","Your input was a hexadecimal string but it was the wrong length.",`input.length is ${e.length} instead of 42`,`input was ${r(e)}`])},typename:"address"};function We(e){if(null===e.provider)throw new s(["You are not connected to a provider.","Have you done AxelClientInstance#connect?"])}const De={assert(e){P.assert(e),e.forEach(Ke.assert)},typename:`array of ${(Ke=Se).typename}`};var Ke;const Re=E(1),Me=E(30),Le=le.medium;var Ve=Object.freeze({__proto__:null,transaction_looker:class{constructor(e,t,n=Re){this.client=e,this.tx_hash=t,this.poll_rate=n}async wait(){for(We(this.client);;){const e=await this.client.provider.request({method:"eth_getTransactionReceipt",params:[this.tx_hash]});if(null!=e)return e;await Ue(this.poll_rate)}}}}),Ge=Object.freeze({__proto__:null});const Je="Consider reviewing the docs at dox.axelapi.xyz/types/api_key",Xe={b:"bot",t:"test",u:"user"},Fe={assert(e){if("string"!=typeof e)throw new o(["API Key was not of type string!","Your api key is a string beginning with 'axl'.","If you don't have one yet, you can get one in the 'API Keys'","section of the Axel dashboard.",Je]);if("axl"!==e.slice(0,3))throw new o([`Could not cast "${e}" to api_key`,"Your api key must begin with 'axl'.",Je]);const t=e[3];if(!Object.keys(Xe).includes(t))throw new o(["Unrecognized key type!",`${e.slice(0,4)} <- '${t}'`,"If you copied this directly from the dashboard, your SDK may be too old!","Perhaps the server has been updated with a new key type. This is quite unlikely, though.","There are three supported API key types:","b - bot","t - test","u - user"]);if("-"!==e[4])throw new o(["Expected a hyphen/dash after Axel key identifier!",`${e}`,"    ^ < < < expected a hyphen there"]);if("0"!==e[5])throw new o(["This SDK only supports version 0 key types!"])},typename:"api_key"},Be={assert(e){if(w.assert(e),m("method",T,e),!y("params",e))return;let t,n;try{return void P.assert(e.params)}catch(e){if(!(e instanceof o))throw e;t=e}try{return void w.assert(e.params)}catch(e){if(!(e instanceof o))throw e;n=e}throw new o(["Tried to assert that value was of type EIP_1193.RequestArguments.","The value satisfied {method: string} but was unable to satisfy","{params?: readonly unknown[] | object}.",n,t])},typename:"EIP_1193.RequestArguments"},Qe={assert(e){if(!(e instanceof Error))throw new o(["A ProviderRpcError must extend Error!"]);m("code",j,e)},typename:"EIP_1193.ProviderRpcError"},Ze={assert(e){try{w.assert(e)}catch(e){throw e instanceof o?new o(["An error was encountered while validating the provider:",e]):e}try{_("request",e)}catch(e){throw new o(["While a provider without a .request method can technically be valid","so long as it has either one of a .send or a .sendAsync method.","This sdk makes extensive use of the .request method and therefore will not","allow you to pass in this provider, even if it *may* technically be valid.","See https://eips.ethereum.org/EIPS/eip-1193"])}g("isMetaMask",$,e),g("isCoinbaseWallet",$,e),v("on",x,e),v("removeListener",x,e),v("request",x,e)},typename:"EIP_1193_Provider"};function et(e){const t={provider_connect:[],provider_disconnect:[],chain_update:[],accounts_update:[]};function n(e,n){for(const s of t[e])try{h(s)(n)}catch(e){console.error(e)}}function a(e){try{De.assert(e)}catch(e){return void n("accounts_update",{status:"error",error:i(e)})}n("accounts_update",{status:"ok",accounts:e})}function r(e){try{K.assert(e)}catch(e){return void n("chain_update",{status:"error",error:i(e)})}if(function(e){const t=f(Z).map((e=>Z[e].chain_id));return n=e,t.includes(n);var n}(e)){n("chain_update",{status:"known",chain:Q(e),chain_id:e})}else n("chain_update",{status:"unknown",chain:null,chain_id:e})}function c(e){n("provider_connect",void 0)}function l(e){try{Qe.assert(e)}catch(e){return void console.error(e)}n("provider_disconnect",e)}e.on=function(e,n){re.assert(e),x.assert(n),function(e,n){t[e].push(n)}(e,u(n))},e.off=function(e,n){return re.assert(e),x.assert(n),function(e,n){return function(e,t){const n=e.indexOf(t);return-1!==n&&(function(e,t){t.splice(e,1)[0]}(n,e),!0)}(t[e],n)}(e,n)},e.connect=async function(){const t=await async function(e){if(e)return Ze.assert(e),e;const t=globalThis.window;try{w.assert(t)}catch(e){throw e instanceof o?"undefined"==typeof process?new o([`Could not assert that window was a ${w.typename}.`,e]):new s(["process global exists which implies that this library is being run in NodeJS.","As such, you must provide your own eip-1193 provider.","There are no users to inject an ExternalProvider into globalThis.ethereum.","To provide your own ExternalProvider, please see the Ethereum documentation:","https://docs.ethers.io/v5/api/providers/other/#Web3Provider--ExternalProvider","This sdk will specifically check for the existence of a .send function"]):e}try{_("ethereum",t)}catch(e){throw e instanceof o?new s(["Tried to connect to a web3 provider but window.ethereum","was not present. Does your user have a wallet installed?",e]):e}try{Ze.assert(t.ethereum)}catch(e){throw e instanceof o?new o(["window.ethereum exists but is not a valid ExternalProvider:",e]):e}return t.ethereum}();t.on("accountsChanged",a),t.on("chainChanged",r),t.on("connect",c),t.on("disconnect",l),r(await t.request({method:"eth_chainId"})),a(await t.request({method:"eth_requestAccounts"})),e.provider=t}}const tt="https://api.axelapi.xyz/v0",nt={assert(e){try{w.assert(e),m("ok",$,e),!1===e.ok&&m("msg",T,e)}catch(e){throw e instanceof o?new o(["While asserting that input was a basic_response, an error was thrown:",e]):e}},typename:"basic_response"};async function st(e,n,a){let r;r=null!=a?function(e){const t=f(e);return 0===t.length?"":`?${t.map((t=>`${t}=${e[t]}`)).join("&")}`}(a):"";const i=`${tt}/${e}${r}`,c=await t.fetch(i,{method:"GET",headers:{Accept:"application/json","X-API-KEY":n,"User-Agent":"@axelapi/sdk"}}),u=await c.json();try{nt.assert(u)}catch(e){throw e instanceof o?new s(["This is probably not your fault.","The server has returned an object which did not have a .ok key of type boolean.","Regardless of the http status response, all valid endpoints should conform","to this response structure.","Please contact the Axel developers immediately with this error message.",`url  = ${i}`,`data = ${Ye(u)}`,e]):e}if(c.status<100)throw new s(["This is probably not your fault.",`The server responded with ${c.status}. Is that even possible?`,"Well, if you're seeing this, something quite wrong has happened.","Please contact the Axel developers with this error message.",`url  = ${i}`,`data = ${Ye(u)}`]);if(c.status<200)throw new s(["Unable to handle 1xx http responses."]);if(c.status<300){if(u.ok)return u;throw new s(["This is probably not your fault.",`The status of the request is ${c.status} but the server returned`,"a response where ok = false. This does not make sense.","Please contact the Axel developers with this error message.",`url  = ${i}`,`data = ${Ye(u)}`])}if(c.status<400)throw new s(["Unable to handle 3xx http responses."]);if(c.status<500){if(u.ok)throw new s(["This is probably not your fault.",`The status of the request is ${c.status} but the server returned`,"a response where ok = true. This does not make sense.","Please contact the Axel developers with this error message.",`url  = ${i}`,`data = ${Ye(u)}`]);throw new s([`${c.status} ${c.statusText}`,u.msg])}if(c.status<600){if(u.ok)throw new s(["This is probably not your fault.",`The status of the request is ${c.status} but the server returned`,"a response where ok = true. This does not make sense.","Please contact the Axel developers with this error message.",`url  = ${i}`,`data = ${Ye(u)}`]);throw new s([`${c.status} ${c.statusText}`,u.msg])}throw new s([`Unable to handle http code ${c.status}!`])}async function ot(e,n,a){const r=`${tt}/${e}`,i=await t.fetch(r,{method:"POST",body:Ye(a),headers:{Accept:"application/json","Content-Type":"application/json","X-API-KEY":n,"User-Agent":"@axelapi/sdk"}}),c=await i.json();try{nt.assert(c)}catch(e){throw e instanceof o?new s(["This is probably not your fault.","The server has returned an object which did not have a .ok key of type boolean.","Regardless of the http status response, all valid endpoints should conform","to this response structure.","Please contact the Axel developers immediately with this error message.",`url  = ${r}`,`body = ${Ye(a)}`,`data = ${Ye(c)}`,e]):e}if(i.status<100)throw new s(["This is probably not your fault.",`The server responded with ${i.status}. Is that even possible?`,"Well, if you're seeing this, something quite wrong has happened.","Please contact the Axel developers with this error message.",`url  = ${r}`,`body = ${Ye(a)}`,`data = ${Ye(c)}`]);if(i.status<200)throw new s(["Unable to handle 1xx http responses."]);if(i.status<300){if(c.ok)return c;throw new s(["This is probably not your fault.",`The status of the request is ${i.status} but the server returned`,"a response where ok = false. This does not make sense.","Please contact the Axel developers with this error message.",`url  = ${r}`,`body = ${Ye(a)}`,`data = ${Ye(c)}`])}if(i.status<400)throw new s(["Unable to handle 3xx http responses."]);if(i.status<500){if(c.ok)throw new s(["This is probably not your fault.",`The status of the request is ${i.status} but the server returned`,"a response where ok = true. This does not make sense.","Please contact the Axel developers with this error message.",`url  = ${r}`,`body = ${Ye(a)}`,`data = ${Ye(c)}`]);throw new s([`${i.status} ${i.statusText}`,c.msg])}if(i.status<600){if(c.ok)throw new s(["This is probably not your fault.",`The status of the request is ${i.status} but the server returned`,"a response where ok = true. This does not make sense.","Please contact the Axel developers with this error message.",`url  = ${r}`,`body = ${Ye(a)}`,`data = ${Ye(c)}`]);throw new s([`${i.status} ${i.statusText}`,c.msg])}throw new s([`Unable to handle http code ${i.status}!`])}const at={assert(e){m("gas",K,e)},typename:"gas_res"};function rt(e,t,n,o){if("externet"===Z[t].type){if(!ve(e,n))throw new s([`Tried to ${o} but protocol ${r(e)} does not support`,`chain ${r(t)} because it does not support it's parent chain ${r(n)}.`])}else{if(t!==n)throw new s(["Logic Error: src/core/client::check_protocol","Please repor this to the Axel developers immediately."]);if(!ve(e,n))throw new s([`Tried to ${o} but protocol ${r(e)}`,`does not support chain ${r(n)}`])}}async function it(e,t,n){const o=Z[t].chain_id;try{await e.provider.request({method:"wallet_switchEthereumChain",params:[{chainId:o}]})}catch(e){throw new s(["User did not want to switch chains!",`Tried switching to "${o}"`])}const a=await e.provider.request(n);return K.assert(a),a}async function ct(e,t){rt(t.protocol,t.client_chain,t.chain,"exchanging");const n=await ot("exchange",e.api_key,t);return function(e){m("rpc_request",Be,e)}(n),it(e,t.client_chain,n.rpc_request)}async function ut(e,t){const n=ee(t.chain),s=await ot("balance",e.api_key,{...t,chain:n});!function(e){m("rpc_request",Be,e),m("decimals",A,e)}(s);const o=await e.provider.request(s.rpc_request);K.assert(o);return R(o,s.decimals)}function ht(e,t){w.assert(e),m("amount",C,e),m("protocol",t,e),g("chain",F,e),g("token",Ie,e),g("wallet_address",Se,e),g("gas_priority",ue,e),g("minutes_timeout",A,e)}async function lt(e,t){var n,s,a,r,i;const c=t.amount,u=t.protocol,h=null!==(n=t.chain)&&void 0!==n?n:await e.get_chain(),l=ee(h),p=null!==(s=t.token)&&void 0!==s?s:ze[l],d=null!==(a=t.wallet_address)&&void 0!==a?a:await e.get_account();if(null===d)throw new o(["You did not supply a wallet_address and the sdk could not infer one.","Have you called AxelClientInstance#connect?"]);return{amount:c,protocol:u,client_chain:h,chain:l,token:p,wallet_address:d,gas_priority:null!==(r=t.gas_priority)&&void 0!==r?r:Le,minutes_timeout:null!==(i=t.minutes_timeout)&&void 0!==i?i:Me}}async function pt(e,t,n){rt(n.protocol,n.client_chain,n.chain,t);const s=await ot(t,e.api_key,n);return m("rpc_request",Be,s),it(e,n.client_chain,s.rpc_request)}const dt=O.borrow.action_class,ft=Te[dt];const wt=O.deposit.action_class,yt=Te[wt];const _t=O.lend.action_class,mt=Te[_t];const gt=O.stake.action_class,vt=Te[gt];const bt=O.supply.action_class,kt=Te[bt];const xt=O.unborrow.action_class,$t=Te[xt];const Tt=O.undeposit.action_class,jt=Te[Tt];const At=O.unlend.action_class,Et=Te[At];const Ct=O.unstake.action_class,Pt=Te[Ct];const It=O.unsupply.action_class,qt=Te[It];function Ot(e){if(!new.target)throw new o(["You must instantiate AxelClientInstance (AxelCoreClient internally)","using 'new'!","",'const {Client} = require("@axelapi/sdk");','const axel = new Client("axlu-0-your-api-key")',"             ~~~","Did you forget this?"]);Fe.assert(e),this.api_key=e,this.provider=null,et(this)}Ot.prototype.get_accounts=async function(){if(null===this.provider)return[];const e=await this.provider.request({method:"eth_accounts"});return De.assert(e),e},Ot.prototype.get_account=async function(){const e=await this.get_accounts();return 0===e.length?null:e[0]},Ot.prototype.get_chain_id=async function(){if(null===this.provider)return null;const e=await this.provider.request({method:"eth_chainId"});try{K.assert(e)}catch(e){throw e instanceof o?new o(["eth_chainId returned something that did not satisfy hex_string!",e]):e}return e},Ot.prototype.get_chain=async function(){const e=await this.get_chain_id();if(null===e)return null;try{B.assert(e)}catch(t){throw t instanceof o?new o(["You are on an unknown chain!",`chain_id = "${e}"`,t]):t}return Q(e)},Ot.prototype.unsafe_estimate_gas=async function(e){const t=await st("gas",this.api_key,{chain:e});return at.assert(t),t.gas},Ot.prototype.estimate_gas=async function(e){return null!=e||(e=await this.get_chain()),F.assert(e),this.unsafe_estimate_gas(e)},Ot.prototype.unsafe_exchange=function(e){return We(this),ct(this,e)},Ot.prototype.exchange=async function(e){var t;return We(this),t=e,w.assert(t),m("sell_amount",C,t),m("sell_token",Ie,t),m("buy_token",Ie,t),g("protocol",$e,t),g("chain",F,t),g("wallet_address",Se,t),g("gas_priority",ue,t),g("minutes_timeout",A,t),ct(this,await async function(e,t){var n,s,a,r,i;const c=t.sell_amount,u=t.sell_token,h=t.buy_token,l=null!==(n=t.protocol)&&void 0!==n?n:"auto",p=null!==(s=t.chain)&&void 0!==s?s:await e.get_chain(),d=ee(p),f=null!==(a=t.wallet_address)&&void 0!==a?a:await e.get_account();if(null===f)throw new o(["You did not supply a wallet_address and the sdk could not infer one.","Have you called AxelClientInstance#connect?"]);return{sell_amount:c,sell_token:u,buy_token:h,protocol:l,client_chain:p,chain:d,wallet_address:f,gas_priority:null!==(r=t.gas_priority)&&void 0!==r?r:le.medium,minutes_timeout:null!==(i=t.minutes_timeout)&&void 0!==i?i:Me}}(this,e))},Ot.prototype.unsafe_get_apy=async function(e,t){const n=await st(`apy_${e}`,this.api_key,t);return function(e){m("apy",C,e)}(n),n.apy},Ot.prototype.get_apy=async function(e,t){!function(e,t){w.assert(t),m("protocol",Te[Y[e]],t),g("chain",G,t),g("token",Ie,t)}(e,t);const n=await async function(e,t){var n,s;const a=t.protocol,r=null!==(n=t.chain)&&void 0!==n?n:await e.get_chain();if(null===r)throw new o(["You did not provide a chain and we could not infer one from the provider.","The provider is not connected"]);if(X(r))throw new o([`You did not provide a chain so it defaulted to the currently chain, "${r}".`,"Unfortunately, this chain is not supported by APY family functions."]);return{protocol:a,chain:r,token:null!==(s=t.token)&&void 0!==s?s:ze[r]}}(this,t);return this.unsafe_get_apy(e,n)},Ot.prototype.unsafe_get_balance=function(e){return We(this),ut(this,e)},Ot.prototype.get_balance=async function(e={}){var t;return We(this),t=e,w.assert(t),g("chain",F,t),g("token",Ie,t),g("wallet_address",Se,t),ut(this,await async function(e,t){var n,s,a;const r=null!==(n=t.chain)&&void 0!==n?n:await e.get_chain(),i=ee(r),c=null!==(s=t.token)&&void 0!==s?s:ze[i],u=null!==(a=t.wallet_address)&&void 0!==a?a:await e.get_account();if(null===u)throw new o(["You did not supply a wallet_address and the sdk could not infer one.","Have you called AxelClientInstance#connect?"]);return{client_chain:r,chain:i,token:c,wallet_address:u}}(this,e))},Ot.prototype.unsafe_borrow=function(e){return We(this),pt(this,"borrow",e)},Ot.prototype.borrow=async function(e){return We(this),ht(e,ft),pt(this,"borrow",await lt(this,e))},Ot.prototype.unsafe_deposit=function(e){return We(this),pt(this,"deposit",e)},Ot.prototype.deposit=async function(e){return We(this),ht(e,yt),pt(this,"deposit",await lt(this,e))},Ot.prototype.unsafe_lend=function(e){return We(this),pt(this,"lend",e)},Ot.prototype.lend=async function(e){return We(this),ht(e,mt),pt(this,"lend",await lt(this,e))},Ot.prototype.unsafe_stake=function(e){return We(this),pt(this,"stake",e)},Ot.prototype.stake=async function(e){return We(this),ht(e,vt),pt(this,"stake",await lt(this,e))},Ot.prototype.unsafe_supply=function(e){return We(this),pt(this,"supply",e)},Ot.prototype.supply=async function(e){return We(this),ht(e,kt),pt(this,"supply",await lt(this,e))},Ot.prototype.unsafe_unborrow=function(e){return We(this),pt(this,"unborrow",e)},Ot.prototype.unborrow=async function(e){return We(this),ht(e,$t),pt(this,"unborrow",await lt(this,e))},Ot.prototype.unsafe_undeposit=function(e){return We(this),pt(this,"undeposit",e)},Ot.prototype.undeposit=async function(e){return We(this),ht(e,jt),pt(this,"undeposit",await lt(this,e))},Ot.prototype.unsafe_unlend=function(e){return We(this),pt(this,"unlend",e)},Ot.prototype.unlend=async function(e){return We(this),ht(e,Et),pt(this,"unlend",await lt(this,e))},Ot.prototype.unsafe_unstake=function(e){return We(this),pt(this,"unstake",e)},Ot.prototype.unstake=async function(e){return We(this),ht(e,Pt),pt(this,"unstake",await lt(this,e))},Ot.prototype.unsafe_unsupply=function(e){return We(this),pt(this,"unsupply",e)},Ot.prototype.unsupply=async function(e){return We(this),ht(e,qt),pt(this,"unsupply",await lt(this,e))};const Nt=i(Ot);exports.Client=Nt,exports.EIP_1193=Ge,exports.actions=z,exports.address=H,exports.api_key=U,exports.apy=S,exports.chains=se,exports.err=oe,exports.events=ie,exports.gas_priority=we,exports.hex_string=ye,exports.lookers=Ve,exports.protocols=Ee,exports.tokens=He;